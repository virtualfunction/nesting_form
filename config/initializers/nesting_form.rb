# Extend different popular form builders
module FormBuilders
  # Adds extra HTML5 data tags for forms that have dynamically added/removed 
  # fields that use nested_attributes_for / associations.
  module FormBuilder
    # Use this in place of fields_for
    #
    # As well as iterating over an association like normal fields for, this will
    # wrap the item in a container so that it can be easily removed/managed with 
    # JavaScript
    #
    # This also generates markup if not supplied for the new items. This gets 
    # held in a javascript object (which for now gets hidden away in a global)
    #
    # This uses the same arguments as fields_for plus these:
    #
    # wrapper_tag - Used to indicate what tag to use as the wrapper. Defaults to 
    # :div. However table based form will probably use :tr
    # 
    # wrapper_html - Add any custom HTML attributes to the wrapper tag with this
    #
    # new_record - Pass a model instance to use for the new record, if you 
    # rather use some pre-populated defaults over a blank record
    #
    # new_record_markup - HTML markup to use for new records. This overrides 
    # any content generated by the fields_for call and ignores anything from the
    # new_record argument
    def nesting_fields_for(*args, &block)
      options       = args.extract_options!.symbolize_keys
      tag_name      = options.delete(:wrapper_tag)  || :div
      html_options  = options.delete(:wrapper_html) || Hash.new
      assocated, item, other = case args.first
        when String, Symbol then [ args[0], args[1], args[2..-1] || [] ]
        else [ ActiveModel::Naming.param_key(args.first), args.first, args[1..-1] || [] ]
      end
      html_options.update :'data-field-wrapper' => assocated
      # New item blueprint markup
      if options[:new_record_markup]
        markup, index = options[:new_record_markup], options[:child_index]
      else
        markup = template.capture do
          new_model = options[:new_record] || model_for(object, assocated)
          blueprint_args = [ assocated, new_model, *(other << options) ]
          options[:child_index] ||= new_model.object_id.abs.to_s
          index = options[:child_index]
          fields_for *blueprint_args do |*args|
            template.content_tag tag_name, html_options.merge(:'data-index' => options[:child_index]) do
              block.call *args
            end
          end
        end
      end
      template.fields_markup[assocated] = { :markup => markup, :index => index }
      # Field
      fields_for *(args << options.except(:child_index)) do |*args|
        item = args.first.object
        template.content_tag tag_name, html_options do
          block.call *args
        end
      end
    end
  
    # Creates a link to create a new record / set of fields
    # 
    # This is like link_to but accepts an association name instead for the 
    # second argument. A fallback URL can use set using :href for the options.
    # 
    # This merely adds a data-association attribute, to track which asscoiation 
    # this acts on
    def link_to_add_field(*args, &block)
      options       = args.extract_options!.symbolize_keys
      association   = args.pop.to_sym
      options['data-add-field']    = association
      args << default_location(options) << options
      template.link_to *args, &block
    end
    
    # Removal link for a set of fields. It will default to the association 
    # directly above in the DOM. Otherwise, pass a symbol to the :association
    # key to explicitly target an association
    def link_to_remove_field(*args, &block)
      options = args.extract_options!.symbolize_keys
      options['data-remove-field'] = options[:association] || true
      args << default_location(options) << options
      hidden_field(:_destroy, :'data-destroy-field' => true) + template.link_to(*args, &block)
    end
    
    protected
    
    # Extract default location or fallback to nothing
    def default_location(options)
      options.delete(:href) || 'javascript:void(0)'
    end

    # Creates a model instance for an association
    def model_for(related, association)
      related.class.reflect_on_association(association).klass.new
    end
  end

  # :nodoc:
  class Default < ::ActionView::Helpers::FormBuilder
    include FormBuilder
  end

  begin
    require 'simple_form'
    # :nodoc:
    class Simple < ::SimpleForm::FormBuilder
      include FormBuilder
    end
  rescue LoadError
  end

  begin
    require 'formtastic'
    # :nodoc:
    class Formtastic < (defined?(::Formtastic::FormBuilder) ? Formtastic::FormBuilder : ::Formtastic::SemanticFormBuilder)
      include FormBuilder
    end
  rescue LoadError
  end
end
